package fr.vergne.access.util;

import fr.vergne.access.Access;
import fr.vergne.access.PullReadAccess;
import fr.vergne.access.PushReadAccess;
import fr.vergne.access.PushReadAccess.PushListener;

/**
 * This {@link AccessFactory} provides several methods to generate different
 * types of {@link Access}es easily.
 * 
 * @author Matthieu Vergne <matthieu.vergne@gmail.com>
 * 
 */
public class AccessFactory {

	/**
	 * This method allows to interact with a {@link PushReadAccess} through a
	 * {@link PullReadAccess}. While the {@link PushReadAccess} provides the
	 * value of a property when it is generated, the {@link PullReadAccess}
	 * allows to keep the control of when we read this value. Basically, the
	 * {@link PullReadAccess} registers a {@link PushListener} to the
	 * {@link PushReadAccess} and store the value generated when it is
	 * generated, allowing to call the {@link PullReadAccess#get()} method at
	 * any time to retrieve the last, updated value.
	 * 
	 * @param push
	 *            the {@link PushReadAccess} to manage
	 * @param initialValue
	 *            the value to store at the creation of the
	 *            {@link PullReadAccess}
	 * @return a {@link PullReadAccess} which allows to retrieve the last value
	 *         generated by the {@link PushReadAccess}
	 */
	@SuppressWarnings("unchecked")
	public <Value> PullReadAccess<Value> createPullForPush(
			final PushReadAccess<Value> push, Value initialValue) {
		final Object[] container = { initialValue };
		final PushListener<Value> listener = new PushListener<Value>() {

			@Override
			public void valueGenerated(Value value) {
				container[0] = value;
			}
		};
		push.addPushListener(listener);
		return new PullReadAccess<Value>() {

			@Override
			public Value get() {
				return (Value) container[0];
			}

			@Override
			protected void finalize() throws Throwable {
				push.removePushListener(listener);
			}
		};
	}

}
