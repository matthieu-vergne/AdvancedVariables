package fr.vergne.data.access.util;

import fr.vergne.data.access.ActiveReadAccess;
import fr.vergne.data.access.ActiveWriteAccess;
import fr.vergne.data.access.PassiveReadAccess;
import fr.vergne.data.access.PassiveReadAccess.ValueListener;
import fr.vergne.data.access.PassiveWriteAccess;
import fr.vergne.data.access.PassiveWriteAccess.ValueGenerator;
import fr.vergne.data.access.PropertyAccess;

/**
 * This {@link AccessFactory} provides several methods to generate different
 * types of {@link PropertyAccess}es easily.
 * 
 * @author Matthieu Vergne <matthieu.vergne@gmail.com>
 * 
 */
public class AccessFactory {

	/**
	 * This method allows to transform an {@link PassiveReadAccess} into a
	 * {@link ActiveReadAccess}. While the {@link PassiveReadAccess} provides
	 * the value of a property when it is generated, the
	 * {@link ActiveReadAccess} allows to keep the control of when we read this
	 * value. Basically, the {@link ActiveReadAccess} registers a
	 * {@link ValueListener} to the {@link PassiveReadAccess} and store the
	 * value generated when it is generated, allowing to call the
	 * {@link ActiveReadAccess#get()} method at any time to retrieve the last,
	 * updated value.
	 * 
	 * @param activeAccess
	 *            the {@link PassiveReadAccess} to manage
	 * @param initialValue
	 *            the value to store at the creation of the
	 *            {@link ActiveReadAccess}
	 * @return a {@link ActiveReadAccess} which allows to retrieve the last
	 *         value generated by the {@link PassiveReadAccess}
	 */
	@SuppressWarnings("unchecked")
	public <Value> ActiveReadAccess<Value> createActiveReadFromPassiveRead(
			final PassiveReadAccess<Value> activeAccess, Value initialValue) {
		final Object[] container = { initialValue };
		final ValueListener<Value> listener = new ValueListener<Value>() {

			@Override
			public void valueGenerated(Value value) {
				container[0] = value;
			}
		};
		activeAccess.addValueListener(listener);
		return new ActiveReadAccess<Value>() {

			@Override
			public Value get() {
				return (Value) container[0];
			}

			@Override
			protected void finalize() throws Throwable {
				activeAccess.removeValueListener(listener);
			}
		};
	}

	/**
	 * This method allows to transform an {@link PassiveWriteAccess} into a
	 * {@link ActiveWriteAccess}. While the {@link PassiveWriteAccess} updates
	 * its new value when it requires it, the {@link ActiveWriteAccess} allows
	 * to keep the control of when we provide this value. Basically, the
	 * {@link ActiveWriteAccess} store the value set through
	 * {@link ActiveWriteAccess#set(Object)} into a variable. The
	 * {@link ValueGenerator} of the {@link PassiveWriteAccess} is set to
	 * provide the stored value when it is requested. Notice that the
	 * {@link ValueGenerator} of the {@link PassiveWriteAccess} is modified in
	 * the process.<br/>
	 * <br/>
	 * <b>ATTENTION:</b> You only acquire the access control, meaning the
	 * ability to decide when you provide the value. You do not acquire the
	 * property control, meaning the ability to decide when the property is
	 * updated. The update decision is still on the property side.
	 * 
	 * @param activeAccess
	 *            the {@link PassiveWriteAccess} to manage
	 * @param initialValue
	 *            the value to store at the creation of the
	 *            {@link ActiveReadAccess}
	 * @return a {@link ActiveWriteAccess} which allows to set the next value of
	 *         the {@link PassiveReadAccess} until consumption
	 */
	@SuppressWarnings("unchecked")
	public <Value> ActiveWriteAccess<Value> createActiveWriteFromPassiveWrite(
			final PassiveWriteAccess<Value> activeAccess, Value initialValue) {
		final Object[] container = { initialValue };
		ValueGenerator<Value> updater = new ValueGenerator<Value>() {

			@Override
			public Value generateValue() {
				return (Value) container[0];
			}
		};
		activeAccess.setValueGenerator(updater);
		return new ActiveWriteAccess<Value>() {

			@Override
			public void set(Value value) {
				container[0] = value;
			}
		};
	}

	/**
	 * This method allows to bridge read/write accesses together. Given that a
	 * {@link PassiveWriteAccess} is available, it produces an
	 * {@link ActiveReadAccess} able to read the value of the
	 * {@link PassiveWriteAccess} on demand.
	 * 
	 * @param passiveAccess
	 *            the {@link PassiveWriteAccess} to bridge
	 * @return the {@link ActiveReadAccess} allowing to read the value on demand
	 */
	public <Value> ActiveReadAccess<Value> createActiveReadFromPassiveWrite(
			final PassiveWriteAccess<Value> passiveAccess) {
		return new ActiveReadAccess<Value>() {

			@Override
			public Value get() {
				return passiveAccess.getValueGenerator().generateValue();
			}
		};
	}

	/**
	 * This method allows to bridge read/write accesses together. Given that a
	 * {@link PassiveReadAccess} is available, it produces an
	 * {@link ActiveWriteAccess} able to write the value of the
	 * {@link PassiveReadAccess} on demand.
	 * 
	 * @param passiveAccess
	 *            the {@link PassiveReadAccess} to bridge
	 * @return the {@link ActiveWriteAccess} allowing to write the value on
	 *         demand
	 */
	public <Value> ActiveWriteAccess<Value> createActiveWriteFromPassiveRead(
			final PassiveReadAccess<Value> passiveAccess) {
		return new ActiveWriteAccess<Value>() {

			@Override
			public void set(Value value) {
				for (ValueListener<Value> listener : passiveAccess
						.getValueListeners()) {
					listener.valueGenerated(value);
				}
			}
		};
	}

}
